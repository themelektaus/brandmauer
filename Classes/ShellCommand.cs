using Renci.SshNet;

using System.Diagnostics;
using System.Text;

namespace Brandmauer;

public class ShellCommand
{
	const string TMP_FOLDER = "/tmp/brandmauer/scripts";
	const string LINE_SEPARATOR = "#----------------------------------------------------------------------";

	public class SshClientConfig
	{
		public string host;
		public string username;
		public string password;

		public bool Remote => !string.IsNullOrEmpty(host);

		public SshClientConfig()
		{
#if DEBUG
			if (!File.Exists("appsettings.Development.json"))
				return;
#else
			if (!File.Exists("appsettings.json"))
				return;
#endif

			IConfigurationBuilder builder = new ConfigurationBuilder();

#if DEBUG
			builder = builder.AddJsonFile("appsettings.Development.json");
#else
			builder = builder.AddJsonFile("appsettings.json");
#endif

			var appSettings = builder.Build();

			host = appSettings.GetValue<string>("SshClient:Host");
			username = appSettings.GetValue<string>("SshClient:Username");
			password = appSettings.GetValue<string>("SshClient:Password");
		}
	}
	public static readonly SshClientConfig sshClientConfig = new();

	public struct Result
	{
		public enum _Type { Unknown, Shell, Remote };
		public enum _Status { Unknown, OK, Warning, Error };
		public _Type Type { get; set; }
		public string TypeName => Type.ToString();
		public _Status StatusCode { get; set; }
		public string Status => StatusCode.ToString();
		public string ScriptFile { get; set; }
		public string ScriptContent { get; set; }
		public string StdOut { get; set; }
		public string StdErr { get; set; }
		public Exception Exception { get; set; }
		public Exception ScpException { get; set; }
		public object Data { get; set; }

		public IResult ToResult(HttpRequest request)
		{
			if (request.Query.TryGetValue("output", out var output))
			{
				if (output == "script")
					return Results.Text(ScriptContent);

				if (output == "stdout")
					return Results.Text(StdOut);

				if (output == "stderr")
					return Results.Text(StdOut);

				if (output == "data")
					return Results.Json(Data);
			}

			return Results.Json(this);
		}
	}

	public string commandText;

	public static Result Execute(string commandText)
	{
		return new ShellCommand { commandText = commandText }.Execute();
	}

	public Result Execute()
	{
		Result result = default;
		result.ScriptFile = $"{TMP_FOLDER}/{DateTime.Now:yyyyMMdd-HHmmss-ffffff}";

		var assemblyName = Utils.GetAssemblyName();

		var lines = new[]
		{
			$"#!/bin/sh",
			"",
			LINE_SEPARATOR,
			$"# Generated by {assemblyName.Name} v{assemblyName.Version}",
			sshClientConfig.Remote
				? "# Executed via ssh client (remote execution)"
				: "# Executed via shell (local execuction)",
			$"# File located at {result.ScriptFile}",
			LINE_SEPARATOR,
			"",
		}.Concat(
			commandText
				.Trim()
				.Replace("\r", "")
				.Split('\n')
				.Select(x => x.Trim())
				.Where(x => x != string.Empty)
				.Where(x => !x.StartsWith('#'))
				.Select(x => $" {x}")
		)
		.Append("")
		.Append(LINE_SEPARATOR)
		.Append("");

		result.ScriptContent = lines.Join('\n');

		if (sshClientConfig.Remote)
			return RemoteExecute(ref result);

		return ShellExecute(ref result);
	}

	static Result ShellExecute(ref Result result)
	{
		result.Type = Result._Type.Shell;

		try
		{
			Directory.CreateDirectory(TMP_FOLDER);
			File.WriteAllText(result.ScriptFile, result.ScriptContent);

			Execute(result.ScriptFile, ref result);

			result.StatusCode = string.IsNullOrEmpty(result.StdErr)
				? Result._Status.OK
				: Result._Status.Error;
		}
		catch (Exception ex)
		{
			result.StatusCode = Result._Status.Error;
			result.Exception = ex;
		}

		return result;
	}

	static Result RemoteExecute(ref Result result)
	{
		result.Type = Result._Type.Remote;

		if (!SshClientExecute($"mkdir -p {TMP_FOLDER}", ref result))
			goto Return;

		if (!ScpClientUpload(result.ScriptContent, result.ScriptFile, ref result))
			goto Return;

		if (!SshClientExecute($"/bin/sh {result.ScriptFile}", ref result))
			goto Return;

		result.StatusCode = Result._Status.OK;

	Return:
		return result;
	}

	static bool SshClientExecute(string commandText, ref Result result)
	{
		using var ssh = new SshClient(
			sshClientConfig.host,
			sshClientConfig.username,
			sshClientConfig.password
		);

		try
		{
			ssh.Connect();

			using var command = ssh.CreateCommand(commandText);

			result.StdOut = command.Execute().Trim();
			result.StdErr = command.Error.Trim();

			if (!string.IsNullOrEmpty(result.StdErr))
				result.StatusCode = Result._Status.Error;
		}
		catch (Exception ex)
		{
			result.StatusCode = Result._Status.Error;
			result.Exception = ex;
		}
		finally
		{
			if (ssh.IsConnected)
				ssh.Disconnect();
		}

		return result.StatusCode != Result._Status.Error;
	}

	static bool ScpClientUpload(string source, string path, ref Result result)
	{
		using var scp = new ScpClient(
			sshClientConfig.host,
			sshClientConfig.username,
			sshClientConfig.password
		);

		try
		{
			scp.Connect();

			using var stream = source.ToStream();
			scp.Upload(stream, path);
		}
		catch (Exception ex)
		{
			result.StatusCode = Result._Status.Error;
			result.ScpException = ex;
		}
		finally
		{
			if (scp.IsConnected)
				scp.Disconnect();
		}

		return result.StatusCode != Result._Status.Error;
	}

	static void Execute(string commandText, ref Result result)
	{
		using var process = new Process();

		process.StartInfo.FileName = "/bin/sh";
		process.StartInfo.Arguments = commandText;
		process.StartInfo.RedirectStandardOutput = true;
		process.StartInfo.RedirectStandardError = true;

		var stdout = new StringBuilder();
		var stderr = new StringBuilder();

		using var stdoutHandle = new AutoResetEvent(initialState: false);
		using var stderrHandle = new AutoResetEvent(initialState: false);

		process.OutputDataReceived += (sender, e) =>
		{
			if (e.Data is null)
				stdoutHandle.Set();

			stdout.AppendLine(e.Data);
		};

		process.ErrorDataReceived += (sender, e) =>
		{
			if (e.Data is null)
				stderrHandle.Set();

			stderr.AppendLine(e.Data);
		};

		process.Start();
		process.BeginErrorReadLine();
		process.BeginOutputReadLine();
		process.WaitForExit();

		stdoutHandle.WaitOne();
		stderrHandle.WaitOne();

		result.StdOut = stdout.ToString().Replace("\r", "").Trim();
		result.StdErr = stderr.ToString().Replace("\r", "").Trim();
	}
}
