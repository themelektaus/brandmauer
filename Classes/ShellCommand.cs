using Renci.SshNet;

using System.Diagnostics;
using System.Text;

namespace Brandmauer;

public class ShellCommand
{
    const string TMP_FOLDER = "/tmp/brandmauer/scripts";

    public struct Result
    {
        public enum _Type { Unknown, Shell, Remote };
        public enum _Status { Unknown, OK, Warning, Error };
        public _Type Type { get; set; }
        public string TypeName => Type.ToString();
        public _Status StatusCode { get; set; }
        public string Status => StatusCode.ToString();
        public string ScriptFile { get; set; }
        public string ScriptContent { get; set; }
        public string StdOut { get; set; }
        public string StdErr { get; set; }
        public Exception Exception { get; set; }
        public Exception ScpException { get; set; }
        public object Data { get; set; }

        public IResult ToResult(HttpRequest request)
        {
            if (request.Query.TryGetValue("output", out var output))
            {
                if (output == "script")
                    return Results.Text(ScriptContent);

                if (output == "stdout")
                    return Results.Text(StdOut);

                if (output == "stderr")
                    return Results.Text(StdOut);

                if (output == "data")
                    return Results.Json(Data);
            }

            return Results.Json(this);
        }
    }

    public string commandText;

    public record RemoteOptions(string Host, string Username, string Password);

    public static Result Execute(string commandText, RemoteOptions remoteOptions = null)
    {
        return new ShellCommand { commandText = commandText }.Execute(remoteOptions);
    }

    public Result Execute(RemoteOptions remoteOptions)
    {
        Result result = default;
        result.ScriptFile = $"{TMP_FOLDER}/{DateTime.Now:yyyyMMdd-HHmmss-ffffff}";

        var assemblyName = Utils.GetAssemblyName();

        var lineSeparator = $"#{Enumerable.Repeat('-', 70).Join()}";

        var lines = new[]
        {
            $"#!/bin/sh",
            "",
            lineSeparator,
            $"# Generated by {assemblyName.Name} v{assemblyName.Version}",
            remoteOptions?.Host is null
                ? "# Executed via shell (local execuction)"
                : "# Executed via ssh client (remote execution)",
            $"# File located at {result.ScriptFile}",
            lineSeparator,
            "",
        }.Concat(
            commandText
                .Trim()
                .Replace("\r", "")
                .Split('\n')
                .Select(x => x.Trim())
                .Where(x => x != string.Empty)
                .Where(x => !x.StartsWith('#'))
                .Select(x => $" {x}")
        )
        .Append("")
        .Append(lineSeparator)
        .Append("");

        result.ScriptContent = lines.Join('\n');

        if (remoteOptions?.Host is null)
            return ShellExecute(ref result);

        return RemoteExecute(ref result, remoteOptions);
    }

    public static Result ShellExecute(ref Result result)
    {
        result.Type = Result._Type.Shell;

        try
        {
            Directory.CreateDirectory(TMP_FOLDER);
            File.WriteAllText(result.ScriptFile, result.ScriptContent);

            Execute(result.ScriptFile, ref result);

            result.StatusCode = string.IsNullOrEmpty(result.StdErr)
                ? Result._Status.OK
                : Result._Status.Error;
        }
        catch (Exception ex)
        {
            result.StatusCode = Result._Status.Error;
            result.Exception = ex;
        }

        return result;
    }

    static Result RemoteExecute(ref Result result, RemoteOptions remoteOptions)
    {
        result.Type = Result._Type.Remote;

        if (!SshClientExecute($"mkdir -p {TMP_FOLDER}", ref result, remoteOptions))
            goto Return;

        var scriptContent = result.ScriptContent;
        var scriptFile = result.ScriptFile;

        if (!ScpClientUpload(scriptContent, scriptFile, ref result, remoteOptions))
            goto Return;

        if (!SshClientExecute($"/bin/sh {scriptFile}", ref result, remoteOptions))
            goto Return;

        result.StatusCode = Result._Status.OK;

    Return:
        return result;
    }

    static bool SshClientExecute(string commandText, ref Result result, RemoteOptions remoteOptions)
    {
        using var ssh = new SshClient(
            remoteOptions.Host,
            remoteOptions.Username,
            remoteOptions.Password
        );

        try
        {
            ssh.Connect();

            using var command = ssh.CreateCommand(commandText);

            result.StdOut = command.Execute().Trim();
            result.StdErr = command.Error.Trim();

            if (!string.IsNullOrEmpty(result.StdErr))
                result.StatusCode = Result._Status.Error;
        }
        catch (Exception ex)
        {
            result.StatusCode = Result._Status.Error;
            result.Exception = ex;
        }
        finally
        {
            if (ssh.IsConnected)
                ssh.Disconnect();
        }

        return result.StatusCode != Result._Status.Error;
    }

    static bool ScpClientUpload(string source, string path, ref Result result, RemoteOptions remoteOptions)
    {
        using var scp = new ScpClient(
            remoteOptions.Host,
            remoteOptions.Username,
            remoteOptions.Password
        );

        try
        {
            scp.Connect();

            using var stream = source.ToStream();
            scp.Upload(stream, path);
        }
        catch (Exception ex)
        {
            result.StatusCode = Result._Status.Error;
            result.ScpException = ex;
        }
        finally
        {
            if (scp.IsConnected)
                scp.Disconnect();
        }

        return result.StatusCode != Result._Status.Error;
    }

    static void Execute(string commandText, ref Result result)
    {
        using var process = new Process();

        process.StartInfo.FileName = "/bin/sh";
        process.StartInfo.Arguments = commandText;
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.RedirectStandardError = true;

        var stdout = new StringBuilder();
        var stderr = new StringBuilder();

        using var stdoutHandle = new AutoResetEvent(initialState: false);
        using var stderrHandle = new AutoResetEvent(initialState: false);

        process.OutputDataReceived += (sender, e) =>
        {
            if (e.Data is null)
                stdoutHandle.Set();

            stdout.AppendLine(e.Data);
        };

        process.ErrorDataReceived += (sender, e) =>
        {
            if (e.Data is null)
                stderrHandle.Set();

            stderr.AppendLine(e.Data);
        };

        process.Start();
        process.BeginErrorReadLine();
        process.BeginOutputReadLine();
        process.WaitForExit();

        stdoutHandle.WaitOne();
        stderrHandle.WaitOne();

        result.StdOut = stdout.ToString().Replace("\r", "").Trim();
        result.StdErr = stderr.ToString().Replace("\r", "").Trim();
    }
}
